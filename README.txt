Team Members: Caleb Bellando, Nick Alvarez, Austin Eubank
Section: CS 4379-001 Homework #1

Algorithm:

Given these variables:
rows: int // Number of rows in the matrix.
cols: int // Number of columns in the matrix
seed: int // Seed for srand().
gran: int // short for granularity (see explanation below)
And four processes.

Do:
Generate a matrix with rows rows and cols columns using seed to generate
random integers [0,32] on process 0. Process 0 must send 1/4 of the rows to
processes 1, 2, and 3. Processes 1, 2, and 3 must calculate the sum of each
row they receive and send the result back to process 0.

Process 0 must calculate the sum of the first rows/4. Process 1 receives the
second block of rows/4. Process 2 receives the third block of rows/4. Process 3
receives the fourth block of rows/4.

Process 0 must display and/or check the results using a brute force check
directly calculating the sum of each row and verifying it against the results
calculated by the other processes.

Granularity - The granularity is initialized in the variable gran. It is
defined as the number of rows generated by process 0 which will be sent to each
of the other processes in a single message. Process 0 generates gran * 3 rows
and sends gran rows to each process as below.

Phase 1 -
Process 0: Process zero generates gran * 3 rows and sends gran rows to each of
the other processes. If gran = 2, for instance, then process 0 generates 6 rows
and sends 2 rows to each of the other processes.

Processes 1,2,3: Each process generates rows/(4 * gran) Irecvs and then begins
waiting on the first Irecv generated. Once an Irecv is completed, the process
then calculates gran sums using the rows just received.

Phase 2 -
Process 0: Process 0 generates 3 Irecvs for the sums from processes 1, 2, and 3.
Then it generates rows/4 and calculates the row sums from each row. These
results are displayed immediately. Process 0 then waits for the sums from the
other processes and displays the results in the appropriate order (1,2,3).

Processes 1,2,3: Once all Irecvs have been completed and the sums calculated,
each process sends the sums to process 0 and then waits to free allocated
memory until the Isend is completed.

Phase 3 -
Process 0: Process 0 then iterates over the matrix and calculates each row sum,
comparing the result to the results from the processes. If an inequality is
discovered, then an alert with the relevant figures is displayed.
