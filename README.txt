Team Members: Caleb Bellando, Nick Alvarez, Austin Eubank
Section: CS 4379-001 Homework #1

Algorithm:

Given these variables:
rows: int // Number of rows in the matrix.
cols: int // Number of columns in the matrix
seed: int // Seed for srand().
gran: int // short for granularity (see explanation below)
And four processes.

Do:
Generate a matrix with rows rows and cols columns using seed to generate
random integers [0,32] on process 0. Process 0 must send 1/4 of the rows to
each of processes 1, 2, and 3. Processes 1, 2, and 3 must calculate the sum of
each row they receive and send the result back to process 0.

Process 0 must calculate the sum of the first rows/4. Process 1 receives the
second block of rows/4. Process 2 receives the third block of rows/4. Process 3
receives the fourth block of rows/4.

Process 0 must display and/or check the results using a brute force check
directly calculating the sum of each row and verifying it against the results
calculated by the other processes.

Granularity - The granularity is initialized in the variable gran. It is
defined as the number of rows generated by process 0 which will be sent to each
of the other processes in a single message. Process 0 generates gran * 3 rows
and sends gran rows to each process as below.

Pseudo-Code:
var: rows:int, cols:int, gran:int, seed:int
On process 0
{
  for(i = 0; i < (rows/(4 * gran)); i++)
  {
    Generate gran * 3 rows in parallel.
    Send each 'packet' of gran rows to each of processes 1, 2, and 3.
  }
  Initiate Irecvs for row sum results from processes 1, 2, and 3.
  Generate, sum, and display lines for process 0.
  Wait until Irecvs are completed and display results in appropriate order.
  Recalculate results and compare against results from other processes.
}
On other processes:
{
  Initiate rows/(4 * gran) Irecvs.
  Wait for each in succession and calculate rows sums as packets are received.
  After all row sums are calculated, send results to process 0.
}

Command Line Arguments:
-rows (requires int argument) Sets the number of rows in the matrix.
-cols (requires int argument) Sets the number of columns in the matrix.
-gran (requires int argument) Sets the granularity of the algorithm.
-print (no argument required) If provided, the program will display individual
                              line sum results.
-seed (requires int argument) Sets the seed of the rand function.


Detail:

Phase 1 -
Process 0: Process zero generates gran * 3 rows and sends gran rows to each of
the other processes. If gran = 2, for instance, then process 0 generates 6 rows
and sends 2 rows to each of the other processes.

Processes 1,2,3: Each process generates rows/(4 * gran) Irecvs and then begins
waiting on the first Irecv generated. Once an Irecv is completed, the process
then calculates gran sums using the rows just received.

Phase 2 -
Process 0: Process 0 generates 3 Irecvs for the sums from processes 1, 2, and 3.
Then it generates rows/4 and calculates the row sums from each row. These
results are displayed immediately. Process 0 then waits for the sums from the
other processes and displays the results in the appropriate order (1,2,3).

Processes 1,2,3: Once all Irecvs have been completed and the sums calculated,
each process sends the sums to process 0 and then waits to free allocated
memory until the Isend is completed.

Phase 3 -
Process 0: Process 0 then iterates over the matrix and calculates each row sum,
comparing the result to the results from the processes. If an inequality is
discovered, then an alert with the relevant figures is displayed.


Notes:
Because of the maximum size of the int data type in C, the user should ensure
that rows * cols < 2147483647.
